# Swing Stakes Backend

This project is a **GraphQL server with TypeScript** with the following stack:

- [**GraphQL Yoga**](https://the-guild.dev/graphql/yoga-server): GraphQL server
- [**Pothos**](https://pothos-graphql.dev/): Code-first GraphQL schema definition library
- [**Prisma Client**](https://www.prisma.io/docs/concepts/components/prisma-client): Databases access (ORM)
- [**Prisma Migrate**](https://www.prisma.io/docs/concepts/components/prisma-migrate): Database migrations
- [**PostgreSQL**](https://www.postgresql.org): SQL database
- [**aws S3**](https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3): File storage

## Contents

- [Getting Started](#getting-started)
- [Using the GraphQL API](#using-the-graphql-api)
- [Evolving the app](#evolving-the-app)
- [Explore and manipulate data](#explore-and-manipulate-data)
- [Access control](#access-control)

## Getting started

### 1. Install dependencies

```sh
npm install
```

### 2. Create and seed the database

Make sure [Docker](https://www.docker.com) is installed and running locally.

Run the following command to create and start your postgres database Docker container in detached mode.

```sh
docker-compose up -d
```

Create and configure an environment file for Prisma to connect with your database instance.

```sh
touch prisma/.env && echo "DATABASE_URL=\"postgresql://postgres:password@localhost:5432/nodeapp\"" > prisma/.env
```

Run the following command to initialize your database.

```sh
npx prisma migrate dev
```

When `npx prisma migrate dev` is executed against a newly created database, seeding is also triggered. The seed file
in [`prisma/seed.ts`](./prisma/seed.ts) will be executed and your database will be populated with the sample data
generated by [**Falso**](https://ngneat.github.io/falso/docs/getting-started).

<details><summary>Expand for more info on the db container</summary>

[**Adminer**](https://www.adminer.org), a lightweight database management tool, is available by browsing
to [http://localhost:8080/](http://localhost:8080/). Enter server: `postgres`. Use this for raw SQL queries, data
exploration and manipulation in lieu of Prisma Studio. Do not create, alter, etc. tables as this is handled by Prisma
Migrate.

Ensure the container is built and executing

```sh
docker ps
```

Stop and remove the database container and networks using the following command.

```sh
docker-compose down
```

Run the following command to create the database migration on your Docker instance.

```sh
npx prisma db push
```

Optionally, seed the database with the sample data in [`prisma/seed.ts`](./prisma/seed.ts) by running the following
command:

```sh
npx prisma db seed
```

</details>

### 3. Configure environment variables

Several features require valid environment variables (defined, for example, in a [`root .env file`](./.env)) to function
properly.

Below are listed only those variables necessary for base functionality. Examine the codebase for instances
of `process.env.` to determine if you need to provide additional variables.

_Note:_ Replace `__YOUR_{VARIABLE_NAME}__` placeholders with appropriate values.

#### Authentication

```sh
JWT_SECRET=__YOUR_JWT_SECRET__
JWT_ISSUER=__YOUR_JWT_ISSUER__
JWT_AUDIENCE=__YOUR_JWT_AUDIENCE__
JWT_ACCESS_TOKEN_EXPIRES_IN=__JWT_ACCESS_TOKEN_EXPIRES_IN__

TWILIO_ACCOUNT_SID=__YOUR_TWILIO_ACCOUNT_SID__
TWILIO_AUTH_TOKEN=__YOUR_TWILIO_AUTH_TOKEN__
TWILIO_SERVICE_ID=__YOUR_TWILIO_SERVICE_ID__
```

#### File storage

```sh
AWS_S3_API_VERSION=__YOUR_AWS_S3_API_VERSION__
AWS_SECRET_ACCESS_KEY=__YOUR_AWS_SECRET_ACCESS_KEY__
AWS_ACCESS_KEY_ID=__YOUR_AWS_ACCESS_KEY_ID__
AWS_S3_REGION=__YOUR_AWS_S3_REGION__
AWS_S3_BUCKET_IMAGE=__YOUR_AWS_S3_BUCKET_IMAGE__

DEFAULT_SIGNED_URL_LIFESPAN=__YOUR_DEFAULT_SIGNED_URL_LIFESPAN__
```

#### Feedback

```sh
SLACK_BOT_TOKEN=__YOUR_SLACK_BOT_TOKEN__
SLACK_CHANNEL_ID=__YOUR_SLACK_CHANNEL_ID__
```

### 4. Start the GraphQL server

Launch your GraphQL server with this command:

```sh
npm run dev
```

Navigate to [http://localhost:4000/graphql](http://localhost:4000/graphql) in your browser to explore the API of your
GraphQL server in a [GraphiQL](https://the-guild.dev/graphql/yoga-server/docs/features/graphiql) instance.

## Using the GraphQL API

The schema that specifies the API operations of the GraphQL server is defined in [`./schema.graphql`](./schema.graphql).
Below are a number of operations that you can send to the API using the GraphiQL playground.

Adjust any operation by adding or removing fields. The GraphiQL playground helps you with its auto-completion and query
validation features.

### Authenticating

Valid access tokens are required for some resolvers. Make sure a valid authentication token is sent along with
the `Bearer`-prefix in the `Authorization` header of the request:

```json
{
  "Authorization": "Bearer __YOUR_TOKEN__"
}
```

### Retrieve first 50 'desert' type courses and their clubs, ordered by name

```graphql
query Courses($orderBy: [CourseOrderBy!], $skip: Int, $take: Int, $where: CourseFilter) {
  courses(orderBy: $orderBy, skip: $skip, take: $take, where: $where) {
    id
    name
    type
    club {
      id
      name
      phoneNumber
      locality
      region
      country
    }
  }
}
```

Variables:

```json
{
  "orderBy": {
    "name": "asc"
  },
  "skip": 0,
  "take": 50,
  "where": {
    "type": {
      "equals": "desert"
    }
  }
}
```

<details><summary><strong>See more API operations</strong></summary>

</details>

## Evolving the app

Evolving the application typically requires two steps:

1. Migrate your database using Prisma Migrate
1. Update your application code

For the following example scenario, assume you want to add a "profile" feature to the app where users can create a
profile and write a short bio about themselves.

### 1. Migrate your database using Prisma Migrate

The first step is to add a new table, e.g. called `Profile`, to the database. You can do this by adding a new model to
your [Prisma schema file](./prisma/schema.prisma) file and then running a migration afterwards:

```diff
// ./prisma/schema.prisma

model User {
  id      Int      @default(autoincrement()) @id
  name    String?
  email   String   @unique
  posts   Post[]
+ profile Profile?
}

model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String
  content   String?
  published Boolean  @default(false)
  viewCount Int      @default(0)
  author    User?    @relation(fields: [authorId], references: [id])
  authorId  Int?
}

+model Profile {
+  id     Int     @default(autoincrement()) @id
+  bio    String?
+  user   User    @relation(fields: [userId], references: [id])
+  userId Int     @unique
+}
```

Once you've updated your data model, you can execute the changes against your database with the following command:

```sh
npx prisma migrate dev --name add-profile
```

This adds another migration to the `prisma/migrations` directory and creates the new `Profile` table in the database.

### 2. Update your application code

You can now use your `PrismaClient` instance to perform operations against the new `Profile` table. Those operations can
be used to implement queries and mutations in the GraphQL API.

#### 2.1. Add the `Profile` type to your GraphQL schema

First, create a new `profile.ts` file add a new GraphQL type via Pothos' `prismaObject` function:

```diff
// ./src/schema/profile.ts
+import { builder } from "../builder";

+builder.prismaObject('Profile', {
+  fields: (t) => ({
+    id: t.exposeInt('id'),
+    bio: t.exposeString('bio', { nullable: true }),
+    user: t.relation('user'),
+  }),
+})
```

Update the `User` object type to include the `profile field:

```diff
// ./src/schema/user.ts

builder.prismaObject('User', {
  fields: (t) => ({
    id: t.exposeInt('id'),
    name: t.exposeString('name', { nullable: true }),
    email: t.exposeString('email'),
    posts: t.relation('posts'),
+    profile: t.relation('profile'),
  }),
})
```

#### 2.2. Add a `createProfile` GraphQL mutation

```diff
// ./src/schema/profile.ts
import { builder } from "../builder";
+import { prisma } from '../db'
+import { User } from './user';

// ... object type


+builder.mutationField('createProfile', (t) =>
+  t.prismaField({
+    type: 'Profile',
+    args: {
+      bio: t.arg.string({ required: true }),
+      data: t.arg({ type: User })
+    },
+    resolve: async (query, _parent, args, _context) =>
+      prisma.profile.create({
+        ...query,
+        data: {
+          bio: args.bio,
+          user: {
+            connect: {
+              id: args.data?.id || undefined,
+              email: args.data?.email || undefined
+            }
+          }
+        }
+      })
+  })
+)
```

Finally, you can test the new mutation like this:

```graphql
mutation {
  createProfile(
    user: {
      email: "mahmoud@prisma.io"
    }
    bio: "I like turtles"
  ) {
    id
    bio
    user {
      id
      name
    }
  }
}
```

<details><summary>Expand to view more sample Prisma Client queries on <code>Profile</code></summary>

Here are some more sample Prisma Client queries on the new <code>Profile</code> model:

##### Create a new profile for an existing user

```ts
const profile = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
      connect: {email: 'alice@prisma.io'},
    },
  },
})
```

##### Create a new user with a new profile

```ts
const user = await prisma.user.create({
  data: {
    email: 'john@prisma.io',
    name: 'John',
    profile: {
      create: {
        bio: 'Hello World',
      },
    },
  },
})
```

##### Update the profile of an existing user

```ts
const userWithUpdatedProfile = await prisma.user.update({
  where: {email: 'alice@prisma.io'},
  data: {
    profile: {
      update: {
        bio: 'Hello Friends',
      },
    },
  },
})
```

</details>

## Explore and manipulate data

Prisma maintains a tool for visualizing and editing data in your database
called [Prisma Studio](https://github.com/prisma/studio).

Run this database IDE from the command line with `npx prisma studio`.
